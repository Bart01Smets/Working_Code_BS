directory = 
  "C:/Users/Robert Shimer/Dropbox/Gregor-Maryam Disease \
Transmission/forgraphs";

No Behavioral Change

SIR[3/10 + 1/7, 1/7, 0.05/365, 0.67/365, 197, 0.0000527, Export -> directory] * Dit is basis-SIR-model*

SIR_gamma0.143_beta0.443_Ni0.0000527.dat

Health Cost and Total Cost: 172.541

Solve model

Input format: solution[\[Alpha],\[Beta],\[Gamma],\[Delta],\[Rho],\[Kappa],Subscript[N, i][0],Export->"directory",FX->$ExchangeRate,Debug->False,Utility->Log].

\[Beta] = 
 3/10 + 1/7; \[Gamma] = 1/7; \[Delta] = 0.67/365; \[Rho] = 0.05/365; \[Kappa] \
= 197; ni0 = 0.0000527; fx = 123;

solution[0, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, Debug -> True,
  Export -> directory, FX -> fx]

Results_alpha0_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 11374

Activity Cost: 1277

Total Cost: 12652 * Dit willen we repliceren*

solution[1, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha1_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 860

Activity Cost: 7227

Total Cost: 8087

solution[0.5, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha0.5_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 8059

Activity Cost: 2582

Total Cost: 10641

solution[0, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx, Utility -> "Quadratic"]

NDSolve::ndsz: At t == -5.10462*10^302, step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndsz: At t == -1.23023*10^302, step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndsz: At t == -1.10189*10^302, step size is effectively zero; singularity or stiff system suspected.

General::stop: Further output of NDSolve::ndsz will be suppressed during this calculation.

Quadratic_alpha0_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 9948

Activity Cost: 1435

Total Cost: 11384

solution[1, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx, Utility -> "Quadratic"]

General::munfl: 1/4.77876*10^307 is too small to represent as a normalized machine number; precision may be lost.

General::munfl: 1/5.66974*10^307 is too small to represent as a normalized machine number; precision may be lost.

General::munfl: 1/6.72684*10^307 is too small to represent as a normalized machine number; precision may be lost.

General::stop: Further output of General::munfl will be suppressed during this calculation.

RowReduce::luc: Result for RowReduce of badly conditioned matrix {{1.18991,-2709.38,0.,0.,0.,0.,3.05282*10^-22},{0.,-9.4768,0.,0.,0.,0.,0.},{0.,-3.2764,1.,0.,0.,0.,0.},{0.,2.552787675036564*10^323,-1.76073,1.18991,0.,0.,-1.25742*10^-6},{0.,-4.576396944833850*10^646,-1.334761910596657*10^324,0.,1.,13.9431,4.471989556929622*10^316},{0.,-1.845319442726283*10^324,59.5641,0.,0.,1.18991,2.51484*10^-6}} may contain significant numerical errors.

RowReduce::luc: Result for RowReduce of badly conditioned matrix {{1.18991,-2709.38,0.,0.,0.,0.,4.31825*10^-22},{0.,-9.4768,0.,0.,0.,0.,0.},{0.,-3.2764,1.,0.,0.,0.,0.},{0.,2.552787675036564*10^323,-1.76073,1.18991,0.,0.,-4.80467*10^-6},{0.,-4.576396944833850*10^646,-1.334761910596657*10^324,0.,1.,13.9431,1.331896256241321*10^317},{0.,-1.845319442726283*10^324,59.5641,0.,0.,1.18991,9.60934*10^-6}} may contain significant numerical errors.

RowReduce::luc: Result for RowReduce of badly conditioned matrix {{1.18991,-2709.38,0.,0.,0.,0.,3.7578*10^-22},{0.,-9.4768,0.,0.,0.,0.,0.},{0.,-3.2764,1.,0.,0.,0.,0.},{0.,2.552787675036564*10^323,-1.76073,1.18991,0.,0.,-0.00001182},{0.,-4.576396944833850*10^646,-1.334761910596657*10^324,0.,1.,13.9431,2.942696633833938*10^317},{0.,-1.845319442726283*10^324,59.5641,0.,0.,1.18991,0.00002364}} may contain significant numerical errors.

General::stop: Further output of RowReduce::luc will be suppressed during this calculation.

NDSolve::ndsz: At t == -2.54964*10^8, step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndcf: Repeated convergence test failure at t == -43568.9; unable to continue.

NDSolve::ndsz: At t == -100150., step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndcf: Repeated convergence test failure at t == -1.22636*10^31; unable to continue.

NDSolve::ndsz: At t == -7.159*10^34, step size is effectively zero; singularity or stiff system suspected.

General::stop: Further output of NDSolve::ndsz will be suppressed during this calculation.

NDSolve::ndcf: Repeated convergence test failure at t == -2.81317*10^34; unable to continue.

General::stop: Further output of NDSolve::ndcf will be suppressed during this calculation.

Quadratic_alpha1_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 214

Activity Cost: 5616

Total Cost: 5830

solution[0, \[Beta], \[Gamma], \[Delta], \[Rho], 0.5 \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha0_gamma0.143_beta0.443_kappa98.5_delta0.00183562_Ni0.0000527.dat

Health Cost: 6763

Activity Cost: 611

Total Cost: 7373

solution[1, \[Beta], \[Gamma], \[Delta], \[Rho], 0.5 \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha1_gamma0.143_beta0.443_kappa98.5_delta0.00183562_Ni0.0000527.dat

Health Cost: 3942

Activity Cost: 2358

Total Cost: 6300

solution[0, 3/10 + 1/18, 1/18, \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

NDSolve::ndsz: At t == -513.39, step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndsz: At t == -1265.44, step size is effectively zero; singularity or stiff system suspected.

NDSolve::ndsz: At t == -1769.04, step size is effectively zero; singularity or stiff system suspected.

General::stop: Further output of NDSolve::ndsz will be suppressed during this calculation.

Results_alpha0_gamma0.0556_beta0.356_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 15973

Activity Cost: 1799

Total Cost: 17772

solution[1, 3/10 + 1/18, 1/18, \[Delta], \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha1_gamma0.0556_beta0.356_kappa197_delta0.00183562_Ni0.0000527.dat

Health Cost: 8776

Activity Cost: 6630

Total Cost: 15406

solution[0, \[Beta], \[Gamma], 0.33/365, \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha0_gamma0.143_beta0.443_kappa197_delta0.00090411_Ni0.0000527.dat

Health Cost: 13541

Activity Cost: 1293

Total Cost: 14834

solution[1, \[Beta], \[Gamma], 0.33/365, \[Rho], \[Kappa], ni0, 
 Export -> directory, FX -> fx]

Results_alpha1_gamma0.143_beta0.443_kappa197_delta0.00090411_Ni0.0000527.dat

Health Cost: 7883

Activity Cost: 4735

Total Cost: 12618

solution[0, \[Beta], \[Gamma], 0, \[Rho], \[Kappa], ni0, Export -> directory, 
 FX -> fx]

Results_alpha0_gamma0.143_beta0.443_kappa197_delta0_Ni0.0000527.dat

Health Cost: 16127

Activity Cost: 1238

Total Cost: 17365

solution[1, \[Beta], \[Gamma], 0, \[Rho], \[Kappa], ni0, Export -> directory, 
 FX -> fx]

Results_alpha1_gamma0.143_beta0.443_kappa197_delta0_Ni0.0000527.dat

Health Cost: 15556

Activity Cost: 713

Total Cost: 16269

solution[0, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], 0.01, 
 Export -> directory, FX -> fx]

Results_alpha0_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.01.dat

Health Cost: 11745

Activity Cost: 1327

Total Cost: 13072

solution[1, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], 0.01, 
 Export -> directory, FX -> fx]

Results_alpha1_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.01.dat

Health Cost: 1852

Activity Cost: 7164

Total Cost: 9016

shock[0, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 210, 20, 1.5, 
 FX -> fx, Export -> directory]

NDSolve::ndsz: At t == -837.844, step size is effectively zero; singularity or stiff system suspected.

Shock_alpha0_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527_T1210_T220_z1.5.dat

shock[1, \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 210, 20, 1.5, 
 FX -> fx, Export -> directory]

Shock_alpha1_gamma0.143_beta0.443_kappa197_delta0.00183562_Ni0.0000527_T1210_T220_z1.5.dat


********************************************************************************************************
***SIR-functie***
********************************************************************************************************
Define functions

Off[NDSolve::evcvmit]; Off[NDSolve::mxst]; Off[
 InterpolatingFunction::dmval]; Off[FindRoot::lstol];
Options[SIR] = {"Export" -> "False"};
SIR[\[Beta]0_, \[Gamma]0_, \[Delta]0_, \[Rho]0_, \[Kappa]0_, ni00_, 
   OptionsPattern[]] := 
  Module[{\[Beta] = \[Beta]0, \[Gamma] = \[Gamma]0, 
    ni0 = ni00, \[Rho] = \[Rho]0, \[Delta] = \[Delta]0, \[Kappa] = \[Kappa]0},
    Clear[nr0]; 
   nr0 = nr0 /. 
     FindRoot[ni0 == 1 - nr0 - Exp[-\[Beta]/\[Gamma] nr0], {nr0, 
       ni0/(\[Beta]/\[Gamma] - 0.99)}]; ns0 = 1 - ni0 - nr0; *De exp... term geeft de initially susceptible aan. De Ni0 is een initial guess, de -0.99 zorgt ervoor dat er niet gedeeld wordt door heel kleine getallen, staat nergens uitgelegd in paper zelf*
   temp = NDSolve[{ns'[t] == -\[Beta] ns[t] ni[t], 
       ni'[t] == \[Beta] ns[t] ni[t] - \[Gamma] ni[t], ns[0] == ns0, 
       ni[0] == ni0, WhenEvent[ni[t] < nifinal, "StopIntegration"]}, {ns, 
       ni}, {t, 0, 10^6}][[1]]; 
   If[OptionValue["Export"] != "False", SetDirectory[OptionValue["Export"]]; 
    Print[Export[
      StringJoin["SIR_gamma", ToString[N[\[Gamma], 3]], "_beta", 
       ToString[N[\[Beta], 3]], "_Ni", 
       ToString[NumberForm[N[ni0], ScientificNotationThreshold -> {-8, 6}]], 
       ".dat"], N[
       Prepend[Append[
         Table[{t, NumberForm[ns[t], ScientificNotationThreshold -> {-8, 6}], 
            NumberForm[ni[t], ScientificNotationThreshold -> {-10, 6}], 
            NumberForm[328000000 0.0062 (1 - ns[t] - ni[t]), 
             ScientificNotationThreshold -> {-8, 9}], 1, 
            N[\[Beta]/\[Gamma] ns[t]]} /. temp, {t, 0, 200}], {730, 
           NumberForm[ns[200], ScientificNotationThreshold -> {-8, 6}], 
           NumberForm[ni[200], ScientificNotationThreshold -> {-10, 6}], 
           NumberForm[328000000 0.0062 (1 - ns[200] - ni[200]), *Wat ik hiervan begrijp is dat ze het tot dag 200 simuleren*
            ScientificNotationThreshold -> {-8, 9}], 1, 
           N[\[Beta]/\[Gamma] ns[200]]} /. temp], {t, Ns, Ni, 
         "Dead_pi_0.0062", A, Rt}]]]]];
   Print[StringJoin["Health Cost and Total Cost: ", 
     ToString[NIntegrate[
       Exp[-(\[Rho] + \[Delta]) t] \[Gamma] \[Kappa] ni[t] /. temp, {t, 0, 
        temp[[1, 2, 1, 1, 2]]}]]]];
   ];

first[temp_] := temp[[1, 2, 1, 1, 1]];
last[temp_] := temp[[1, 2, 1, 1, 2]];



nifinal = 10^-9;
tolerance = 10^-6;
*****************************************************************************************************
***Solution (belangrijkste functie)***
*****************************************************************************************************
Options[solution] = {"Export" -> "False", "Utility" -> "Log", 
  "Debug" -> "False", "FX" -> 1, "Ns0" -> "SIR", "Silent" -> "False"}; 
solution[\[Alpha]0_, \[Beta]0_, \[Gamma]0_, \[Delta]0_, \[Rho]0_, \[Kappa]0_, 
  ni00_, OptionsPattern[]] := 
 Module[{\[Alpha] = \[Alpha]0, \[Beta] = \[Beta]0, \[Gamma] = \[Gamma]0, \
\[Delta] = \[Delta]0, \[Rho] = \[Rho]0, \[Kappa] = \[Kappa]0, ni0 = ni00, 
   R0 = \[Beta]0/\[Gamma]0, fx = OptionValue["FX"]},
  If[OptionValue["Export"] != "False", SetDirectory[OptionValue["Export"]]];
  
  (* Invert optimality condition to find a[t].  
  Only programmed for two utility functions *)
  If[OptionValue["Utility"] == "Log",
   a[\[Alpha]_, \[Beta]_, ns_, ni_, \[Lambda]s_, \[Lambda]i_] := (-(ns + ni) +
      Sqrt[ns + ni] Sqrt[
      ns + ni + 4 (1 + \[Alpha]) \[Beta] ni ns (\[Lambda]s - \[Lambda]i)])/(
    2 (1 + \[Alpha]) \[Beta] ns ni (\[Lambda]s - \[Lambda]i)); *Individuele welvaartsfunctie afgeleid naar a_t, dit is equation voor optimale a_t in laissez-faire
   u[a_] := Log[a] - a + 1]; *Log functie voor utility, deze wordt gebruikt in paper
  If[OptionValue["Utility"] == "Quadratic",
   a[\[Alpha]_, \[Beta]_, ns_, ni_, \[Lambda]s_, \[Lambda]i_] := (ns + ni)/(
    ns + ni + (1 + \[Alpha]) \[Beta] ns ni (\[Lambda]s - \[Lambda]i));
   u[a_] := -1/2 (1 - a)^2;
   ];
  If[OptionValue["Ns0"] == "SIR",
   (*  Initial value of Subscript[N, r]; determined by assumption that A[
   t]\[Equal]1 for t < 1 *)
   Clear[nr0]; 
   nr0 = nr0 /. 
     FindRoot[ni0 == 1 - nr0 - Exp[-\[Beta]/\[Gamma] nr0], {nr0, 
       ni0/(\[Beta]/\[Gamma] - 1)}];
   ns0 = 1 - ni0 - nr0;  (* Initial value for Subscript[N, s] *),
   
   (* Initial value of Subscript[N, s] specified exogenously *)
   ns0 = OptionValue["Ns0"];
   nr0 = 1 - ns0 - ni0];
  
  loop = 0; (* Counts how many times we re-search for Subscript[N, s].  *)
  T[loop] = 0;  (* Normalize terminal date to 0 *)
  stopper = 0;  (* Will switch to 1 when we have found the saddle path *)
  
  nsMax = 1; nsMin = 0;(* 
  Extreme possibilities for terminal condition for Subscript[N, s] *)
  
  {niT, \[Lambda]sT, \[Lambda]iT, HealthCostT, 
    TotalCostT} = {nifinal, (\[Beta] \[Lambda]i[T[loop]] ni[
      T[loop]])/(\[Rho] + \[Delta] + \[Beta] ni[
       T[loop]]), -((\[Gamma] \[Kappa] (\[Delta] + \[Rho] + \[Beta] ni[
          T[loop]]))/(\[Alpha] \[Beta]^2 ni[T[loop]] ns[
        T[loop]] + (\[Delta] + \[Rho] + \[Beta] ni[
           T[loop]]) (\[Rho] + \[Delta] + \[Gamma] - \[Alpha] \[Beta] ns[
           T[loop]]))), 0, 0};  (* Terminal conditions for Subscript[N, i]
   and two costates.  
  Costate conditions are determined by setting Subscript[\[Lambda], i]'[
  T]\[Equal]Subscript[\[Lambda], s]'[T]\[Equal]0 *)
  
  
  (* Main loop *)
  While[stopper == 0,
   
   (* Find the terminal value of Subscript[N, s] *)
   While[nsMax - nsMin > 10^-12,  (* 
    Stops when upper and lower bounds on Subscript[N, s] lie within 10^-12 *)
    trigger = 0;
    temp = 
     NDSolve[{ns'[
          t] == -\[Beta] a[\[Alpha], \[Beta], ns[t], 
           ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[t] ni[t],
        ni'[
          t] == \[Beta] a[\[Alpha], \[Beta], ns[t], 
            ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[t] ni[t] - \[Gamma] ni[
            t],
        (\[Rho] + \[Delta]) \[Lambda]s[t] - \[Lambda]s'[t] == 
         u[a[\[Alpha], \[Beta], ns[t], 
            ni[t], \[Lambda]s[t], \[Lambda]i[
             t]]] + (\[Lambda]i[t] - \[Lambda]s[
              t]) \[Beta] a[\[Alpha], \[Beta], ns[t], 
            ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ni[t],
        (\[Rho] + \[Delta]) \[Lambda]i[t] - \[Lambda]i'[t] == 
         u[a[\[Alpha], \[Beta], ns[t], 
            ni[t], \[Lambda]s[t], \[Lambda]i[
             t]]] + \[Alpha] (\[Lambda]i[t] - \[Lambda]s[
              t]) \[Beta] a[\[Alpha], \[Beta], ns[t], 
            ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[
            t] - \[Gamma] (\[Kappa] + \[Lambda]i[t]),
        HealthCost'[
          t] == (\[Rho] + \[Delta]) HealthCost[t] - \[Gamma] \[Kappa] ni[t], *Dit is de geïntegreerde health cost afgeleid naar t, zelfde voor total cost*
        TotalCost'[
          t] == (\[Rho] + \[Delta]) TotalCost[t] + (ns[t] + ni[t]) u[
            a[\[Alpha], \[Beta], ns[t], 
             ni[t], \[Lambda]s[t], \[Lambda]i[t]]] - \[Gamma] \[Kappa] ni[t],
        ns[T[loop]] == (nsMax + nsMin)/2, 
        ni[T[loop]] == 
         niT, \[Lambda]s[T[loop]] == \[Lambda]sT, \[Lambda]i[
          T[loop]] == \[Lambda]iT, HealthCost[T[loop]] == HealthCostT, 
        TotalCost[T[loop]] == TotalCostT,
        WhenEvent[ns[t] >= ns0 || ni[t] <= nifinal, "StopIntegration"]}, {ns, 
        ni, \[Lambda]s, \[Lambda]i, HealthCost, TotalCost}, {t, -\[Infinity], 
        T[loop]}][[1]];  (* Solve ODE system.  
    Note the extra equations allow us to directly compute health costs and \
total costs *)
    
    If[ns[first[temp]] + ni[first[temp]] < ns0 + ni0 /. temp,
     neg = temp; nsMax = (nsMax + nsMin)/2,
     pos = temp; nsMin = (nsMax + nsMin)/2] (* 
    Check whether solution lies above or below saddle path and store it *)
    ]; 
   
   (* Save intermediate results if debug is on *)
   If[OptionValue["Debug"] == True,
    
    Export[
     StringJoin[
      If[OptionValue["Utility"] == "Log", "Results", 
       If[OptionValue["Utility"] == "Quadratic", "Quadratic"]], "_alpha", 
      ToString[\[Alpha]], "_gamma", ToString[N[\[Gamma], 3]], "_beta", 
      ToString[N[\[Beta], 3]], "_kappa", ToString[\[Kappa]], "_delta", 
      ToString[N[\[Delta], 3]], "_Ni", 
      ToString[NumberForm[N[ni0], ScientificNotationThreshold -> {-8, 6}]], 
      "_pos", ToString[loop], ".dat"], 
     N[Prepend[
       Table[{t, NumberForm[ns[t], ScientificNotationThreshold -> {-8, 6}], 
          NumberForm[ni[t], ScientificNotationThreshold -> {-12, 6}]} /. 
         pos, {t, last[pos], first[pos], -1}], {t, Ns, Ni}]]];
    
    Export[
     StringJoin[
      If[OptionValue["Utility"] == "Log", "Results", 
       If[OptionValue["Utility"] == "Quadratic", "Quadratic"]], "_alpha", 
      ToString[\[Alpha]], "_gamma", ToString[N[\[Gamma], 3]], "_beta", 
      ToString[N[\[Beta], 3]], "_kappa", ToString[\[Kappa]], "_delta", 
      ToString[N[\[Delta], 3]], "_Ni", 
      ToString[NumberForm[N[ni0], ScientificNotationThreshold -> {-8, 6}]], 
      "_neg", ToString[loop], ".dat"], 
     N[Prepend[
       Table[{t, NumberForm[ns[t], ScientificNotationThreshold -> {-8, 6}], 
          NumberForm[ni[t], ScientificNotationThreshold -> {-12, 6}]} /. 
         neg, {t, last[neg], first[neg], -1}], {t, Ns, Ni}]]]
    ];
    
   sol[loop] = temp;  (* Store solution that is closes to the saddle path *)
   
   (* If we did not hit the desired initial condition, 
   look for the point when the paths above and below the saddle where the two \
paths first diverge by at least "tolerance" (in logs).  
   This is the new terminal condition for the ODE system*)
   If[Abs[ns[first[temp]] + ni[first[temp]] - ns0 - ni0] < tolerance /. temp,
    stopper = 1; T[loop + 1] = first[temp],
    T0 = Max[first[neg], first[pos]];
    If[Abs[Log[(ns[T0] /. neg)/(ns[T0] /. pos)]] > tolerance, 
     t1 = t /. 
       FindRoot[Abs[Log[(ns[t] /. neg)/(ns[t] /. pos)]] == tolerance, {t, T0, 
         T[loop]}], t1 = T0];
    If[Abs[Log[(ni[T0] /. neg)/(ni[T0] /. pos)]] > tolerance, 
     t2 = t /. 
       FindRoot[Abs[Log[(ni[t] /. neg)/(ni[t] /. pos)]] == tolerance, {t, T0, 
         T[loop]}], t2 = T0];
    If[Abs[Log[(\[Lambda]s[T0] /. neg)/(\[Lambda]s[T0] /. pos)]] > tolerance, 
     t3 = t /. 
       FindRoot[Abs[Log[(\[Lambda]s[t] /. neg)/(\[Lambda]s[t] /. pos)]] == 
         tolerance, {t, T0, T[loop]}], t3 = T0];
    If[Abs[Log[(\[Lambda]i[T0] /. neg)/(\[Lambda]i[T0] /. pos)]] > tolerance, 
     t4 = t /. 
       FindRoot[Abs[Log[(\[Lambda]i[t] /. neg)/(\[Lambda]i[t] /. pos)]] == 
         tolerance, {t, T0, T[loop]}], t4 = T0];
    T[loop + 1] = Max[t2, t2, t3, t4];
    loop += 1;
    (* Set the terminal values, 
    including the new extreme points for Subscript[N, s] *)
    {nsMax, nsMin, niT, \[Lambda]sT, \[Lambda]iT, HealthCostT, 
      TotalCostT} = {Min[(ns0 + ns[T[loop]])/2, 1.1 ns[T[loop]]], 
       0.9 ns[T[loop]], ni[T[loop]], \[Lambda]s[T[loop]], \[Lambda]i[T[loop]],
        HealthCost[T[loop]], TotalCost[T[loop]]} /. temp];
   ];
  steps = loop;
  
  (* Export results *)
  If[OptionValue["Export"] != "False",
   Print[Export[
     StringJoin[
      If[OptionValue["Utility"] == "Log", "Results", 
       If[OptionValue["Utility"] == "Quadratic", "Quadratic"]], "_alpha", 
      ToString[\[Alpha]], "_gamma", ToString[N[\[Gamma], 3]], "_beta", 
      ToString[N[\[Beta], 3]], "_kappa", ToString[\[Kappa]], "_delta", 
      ToString[N[\[Delta], 3]], "_Ni", 
      ToString[NumberForm[N[ni0], ScientificNotationThreshold -> {-8, 6}]], 
      ".dat"], N[
      Prepend[Take[
        Partition[
         Flatten[Table[
           Table[{t - T[steps + 1], 
              NumberForm[ns[t], ScientificNotationThreshold -> {-8, 6}], 
              NumberForm[ni[t], ScientificNotationThreshold -> {-8, 6}], 
              NumberForm[328000000 0.0062 (1 - ns[t] - ni[t]), 
               ScientificNotationThreshold -> {-8, 9}], 
              NumberForm[
               a[\[Alpha], \[Beta], ns[t], 
                ni[t], \[Lambda]s[t], \[Lambda]i[t]], 
               ScientificNotationThreshold -> {-8, 6}], 
              NumberForm[
               Log[\[Beta]/\[Gamma] a[\[Alpha], \[Beta], ns[t], 
                  ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2], 
               ScientificNotationThreshold -> {-8, 6}], 
              NumberForm[\[Beta]/\[Gamma] a[\[Alpha], \[Beta], ns[t], 
                 ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[t], 
               ScientificNotationThreshold -> {-8, 6}], 
              NumberForm[
               fx Exp[-(\[Delta] + \[Rho]) (t - 
                    T[steps + 1])] \[Gamma] \[Kappa] ni[t], 
               ScientificNotationThreshold -> {-8, 6}],
              
              NumberForm[
               fx Exp[-(\[Delta] + \[Rho]) (t - 
                    T[steps + 1])] (\[Gamma] \[Kappa] ni[
                    t] - (ns[t] + ni[t]) u[
                    a[\[Alpha], \[Beta], ns[t], 
                    ni[t], \[Lambda]s[t], \[Lambda]i[t]]]), 
               ScientificNotationThreshold -> {-8, 6}]} /. sol[n], {t, 
             T[n + 1], Min[T[n], T[steps + 1] + 4 730]}], {n, steps, 
            Floor[x] /. 
             FindRoot[Interpolation[
                 Table[{n, T[n] - T[steps + 1]}, {n, steps + 1, 0, -1}], 
                 InterpolationOrder -> 1][x] == 2 730, {x, steps}], -1}]], 9],
         740], {t, Ns, Ni, "Dead_pi_0.0062", A, LogRS, Rt, DiscHealthCost, 
        DiscTotalCost}]]]]];
  
  If[OptionValue["Silent"] == "False",
   (* Report health and total costs *)
   Print[StringJoin["Health Cost: ", 
     ToString[Round[fx HealthCost[T[steps + 1]]] /. sol[steps]]]];
   Print[StringJoin["Activity Cost: ", 
     ToString[Round[
        fx (TotalCost[T[steps + 1]] - HealthCost[T[steps + 1]])] /. 
       sol[steps]]]];
   Print[StringJoin["Total Cost: ", 
     ToString[Round[fx TotalCost[T[steps + 1]]] /. sol[steps]]]];
   ];
  ];

****************************************************************************
***Shock functie- heb dit geïntegreerd in R, maar in de uiteindelijke code wordt dit normaal niet gebruikt (dus niet belangrijk)***
****************************************************************************

Options[shock] = {"Export" -> "False", "FX" -> 1}; 
shock[\[Alpha]0_, \[Beta]0_, \[Gamma]0_, \[Delta]0_, \[Rho]0_, \[Kappa]0_, 
  ni00_, T10_, T20_, z0_, OptionsPattern[]] := 
 Module[{\[Alpha] = \[Alpha]0, \[Beta] = \[Beta]0, \[Gamma] = \[Gamma]0, \
\[Delta] = \[Delta]0, \[Rho] = \[Rho]0, \[Kappa] = \[Kappa]0, ni0 = ni00, 
   R0 = \[Beta]0/\[Gamma]0, T1 = T10, T2 = T20, z = z0, 
   fx = OptionValue["FX"]},
  If[OptionValue["Export"] != "False", SetDirectory[OptionValue["Export"]]];
  
  (* Initial phase *)
  solution[\[Alpha], \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], ni0, 
   FX -> fx, Silent -> True];
  results1 = 
   N[Take[Partition[
      Flatten[Table[
        Table[{t - T[steps + 1], ns[t], ni[t], 
           328000000 .0062 (1 - ns[t] - ni[t]), 
           a[\[Alpha], \[Beta], ns[t], ni[t], \[Lambda]s[t], \[Lambda]i[t]], 
           Log[\[Beta]/\[Gamma] a[\[Alpha], \[Beta], ns[t], 
              ni[t], \[Lambda]s[t], \[Lambda]i[
               t]]^2], \[Beta]/\[Gamma] a[\[Alpha], \[Beta], ns[t], 
             ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[t], 
           fx Exp[-(\[Delta] + \[Rho]) (t - 
                T[steps + 1])] \[Gamma] \[Kappa] ni[t],
           
           fx Exp[-(\[Delta] + \[Rho]) (t - 
                T[steps + 1])] (\[Gamma] \[Kappa] ni[t] - (ns[t] + ni[t]) u[
                a[\[Alpha], \[Beta], ns[t], 
                 ni[t], \[Lambda]s[t], \[Lambda]i[t]]])} /. sol[n], {t, 
          T[n + 1], Min[T[n], T[steps + 1] + 4 730]}], {n, steps, 
         Floor[x] /. 
          FindRoot[Interpolation[
              Table[{n, T[n] - T[steps + 1]}, {n, steps + 1, 0, -1}], 
              InterpolationOrder -> 1][x] == 2 730, {x, steps}], -1}]], 9], 
     T1 + T2 + 1]];
  
  (* Surprise at T1 with new value for \[Beta] \[Rule] z \[Beta] *)
  ns1 = Evaluate[
     Interpolation[
      Transpose[{Transpose[results1][[1]], Transpose[results1][[2]]}]]][T1];
  ni1 = Evaluate[
     Interpolation[
      Transpose[{Transpose[results1][[1]], Transpose[results1][[3]]}]]][T1];
  A = Evaluate[
    Interpolation[
     Transpose[{Transpose[results1][[1]], Transpose[results1][[5]]}]]];
  temp = NDSolve[{ns'[t] == -z \[Beta] A[t]^2 ns[t] ni[t],
      ni'[t] == z \[Beta] A[t]^2 ns[t] ni[t] - \[Gamma] ni[t], ns[T1] == ns1, 
      ni[T1] == ni1}, {ns, ni}, {t, T1, T1 + T2}][[1]];
  results2 = 
   Table[{t, ns[t], ni[t], 328000000 0.0062 (1 - ns[t] - ni[t]), A[t], 
      Log[((z \[Beta]) A[t]^2)/\[Gamma]], ((z \[Beta]) A[t]^2 ns[t])/\[Gamma],
       fx Exp[-(\[Delta] + \[Rho]) t] \[Gamma] \[Kappa] ni[t], 
      fx Exp[-(\[Delta] + \[Rho]) t] (\[Gamma] \[Kappa] ni[
           t] - (ns[t] + ni[t]) u[A[t]])} /. temp, {t, T1, T1 + T2}];
  
  (* Learn about this at T1+T2 *)
  solution[\[Alpha], z \[Beta], \[Gamma], \[Delta], \[Rho], \[Kappa], 
   results2[[-1, 3]], FX -> fx, Ns0 -> results2[[-1, 2]], Silent -> True];
  results3 = 
   Drop[N[Take[
      Partition[
       Flatten[Table[
         Table[{t - T[steps + 1] + T1 + T2, ns[t], ni[t], 
            328000000 0.0062 (1 - ns[t] - ni[t]), 
            a[\[Alpha], z \[Beta], ns[t], 
             ni[t], \[Lambda]s[t], \[Lambda]i[t]], 
            Log[(z \[Beta])/\[Gamma] a[\[Alpha], z \[Beta], ns[t], 
               ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2], (
             z \[Beta])/\[Gamma] a[\[Alpha], z \[Beta], ns[t], 
              ni[t], \[Lambda]s[t], \[Lambda]i[t]]^2 ns[t], 
            fx Exp[-(\[Delta] + \[Rho]) (t - 
                 T[steps + 1])] \[Gamma] \[Kappa] ni[t],
            
            fx Exp[-(\[Delta] + \[Rho]) (t - 
                 T[steps + 1])] (\[Gamma] \[Kappa] ni[t] - (ns[t] + ni[t]) u[
                 a[\[Alpha], z \[Beta], ns[t], 
                  ni[t], \[Lambda]s[t], \[Lambda]i[t]]])} /. sol[n], {t, 
           T[n + 1], Min[T[n], T[steps + 1] + 4 730]}], {n, steps, 
          Floor[x] /. 
           FindRoot[Interpolation[
               Table[{n, T[n] - T[steps + 1]}, {n, steps + 1, 0, -1}], 
               InterpolationOrder -> 1][x] == 2 730, {x, steps}], -1}]], 9], 
      740 - (T1 + T2)]], 1];
  results = Transpose[Join[Take[results1, T1], results2, results3]];
  
  If[OptionValue["Export"] != "False",
   Print[Export[
     StringJoin["Shock", "_alpha", ToString[\[Alpha]], "_gamma", 
      ToString[N[\[Gamma], 3]], "_beta", ToString[N[\[Beta], 3]], "_kappa", 
      ToString[\[Kappa]], "_delta", ToString[N[\[Delta], 3]], "_Ni", 
      ToString[NumberForm[N[ni0], ScientificNotationThreshold -> {-8, 6}]], 
      "_T1", ToString[T1], "_T2", ToString[T2], "_z", ToString[z], ".dat"],
     N[Prepend[Transpose[{results[[1]],
         Table[
          NumberForm[results[[2, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[3, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[4, i]], 
           ScientificNotationThreshold -> {-8, 9}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[5, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[6, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[7, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[8, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}],
         Table[
          NumberForm[results[[9, i]], 
           ScientificNotationThreshold -> {-8, 6}], {i, 1, 
           Length[Transpose[results]]}]}], {t, Ns, Ni, "Dead_pi_0.0062", "A", 
        LogRS, Rt, DiscHealthCost, DiscTotalCost}]]]]];
  ];
